<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IA TP1</title>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.7/p5.min.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Jeu de la vie - mode Survie</h3>
    <p>Les cellules ont des points de vie régissant leur survie dans cet environnement similaire au jeu de la vie de Conway.
        Les cellules qui ont toute leur vie (complètement noires) restent indéfiniment.
    </p>
    <p>Contrôles : clic = placer des cellules | espace = jouer | N = état suivant | X = remettre à zéro</p>
</body>
</html>

<script>
    // code basé sur cette version p5 :
    // https://p5js.org/examples/simulate-game-of-life.html

    function draw() 
    {
        background(150);
    }

    let w;
    let columns;
    let rows;
    let board;
    let next;
    let running = false;

    function setup() {
        // Setup du canvas
        frameRate(20);
        createCanvas(1200, 600);

        // Taille des cellules
        w = 16;

        // Nombre de colonne et de ligne
        columns = floor(width / w);
        rows = floor(height / w);

        // Création du tableau de l'état courant
        board = new Array(columns);
        for (let i = 0; i < columns; i++) 
        {
            board[i] = new Array(rows);
        }

        // Création du tableau de l'état suivant
        next = new Array(columns);
        for (i = 0; i < columns; i++) 
        {
            next[i] = new Array(rows);
        }
        zeroBoard();
    }

    function draw() {
        background(255);

        drawCells();

        if (running) {
            // Génération du nouvel état
            generate();
        }

        
        gridMouseX = floor(mouseX / w) * w;
        gridMouseY = floor(mouseY / w) * w;
        fill(128);
        rect(gridMouseX, gridMouseY, w, w);
    }
    
    function drawCells() {
        // Remplissage des cellules
        for ( let i = 0; i < columns;i++) 
        {
            for ( let j = 0; j < rows;j++) 
            {
                fill(255-(255 / 10 * board[i][j]))

                if (board[i][j] == 0 && !running) {
                    fill(240, 243, 245)
                }

                noStroke()
                rect(i * w, j * w, w, w);
            }
        }
    }

    function mouseDragged() 
    {
        editCell();
    }

    function mousePressed() {
        editCell();
    }

    function editCell() 
    {
        i = floor(mouseX / w);
        j = floor(mouseY / w);
        
        if (board[i][j] == 9)
            board[i][j] = 0
        else 
            board[i][j] = floor(random(5)+5);

        drawCells;
    }

    function keyPressed()
    {
        // Espace
        if (keyCode == 32) {
            running = !running;
        }
        
        // N
        if (keyCode == 78) {
            // next step
            generate();
            drawCells();
        }

        // X = réinitialiser le tableau
        if (keyCode == 88) {
            zeroBoard();
        }
    }

    // Mettre le tableau à zéro
    function zeroBoard() 
    {
        for (let i = 0; i < columns; i++) 
        {
            for (let j = 0; j < rows; j++) 
            {
                board[i][j] = 0;
                next[i][j] = 0;
            }
        }
    }

    // The process of creating the new generation
    function generate() {

    // Loop through every spot in our 2D array and check spots neighbors
    for (let x = 1; x < columns - 1; x++) {
    for (let y = 1; y < rows - 1; y++) {
        // Add up all the states in a 3x3 surrounding grid
        let neighbors = 0;
        for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
            if (board[x+i][y+j] > 0){
            neighbors += 1;
            }
        }
        }

        // A little trick to subtract the current cell's state since
        // we added it in the above loop
        if (board[x][y] > 0){
        neighbors -= 1;
        }
        // Rules of Life
        if      (board[x][y] >= 9){
        next[x][y] = board[x][y];           // Sauvegarde
        }
        else if      ((board[x][y] > 0) && (neighbors <  2)) {
        next[x][y] = board[x][y] - 3        // Loneliness
        }           
        else if ((board[x][y] > 0) && (neighbors >  3)) {
        next[x][y] = board[x][y] - 6;       // Overpopulation       
        } 
        else if ((board[x][y] < 9) && (neighbors == 3)) {
        next[x][y] = board[x][y] + 1;     // Reproduction   
        }       
        else {                                        
        next[x][y] = board[x][y];    // Stasis
        }
        
        if (next[x][y] < 0) {
        next[x][y] = 0;
        }
    }
    }

    // Swap!
    let temp = board;
    board = next;
    next = temp;
    }

</script>